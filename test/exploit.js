const { expect } = require('chai');
const { ethers } = require('ethers');
const {
	ethers: { utils },
} = require('hardhat');
const hre = require('hardhat');
const { setTokenBalance } = require('./utils');

const BASE_TOKEN = '0x55d398326f99059fF775485246999027B3197955'; //USDT
const ROUTER = '0x10ED43C718714eb63d5aA57B78B54704E256024E'; //pancake v2
const TREASURY = '0xfA7C77a21A482A2B3cF40C09741148632b9E1Df2';
const NEW_TOKEN_PRICE = 1;

let NEW_TOKEN;
let platformAdmin, attacker;
let vault, govToken, icoGov, baseTokenContract;

describe('Cross-Contract Reentrancy Attack', function () {
	it('Setup', async function () {
		[platformAdmin, attacker] = await hre.ethers.getSigners();

		//Vault
		const Vault = await hre.ethers.getContractFactory('Vault', platformAdmin);
		vault = await Vault.deploy(BASE_TOKEN, ROUTER);
		await vault.deployed();
		console.log('Vault deployed to:', vault.address);

		// GOVToken
		const GOVToken = await hre.ethers.getContractFactory('GOVToken', platformAdmin);
		govToken = await GOVToken.deploy();
		await govToken.deployed();
		console.log('GOVToken deployed to:', govToken.address);

		// ICOGov
		NEW_TOKEN = govToken.address;

		const ICOGov = await hre.ethers.getContractFactory('ICOGov', platformAdmin);
		icoGov = await ICOGov.deploy(NEW_TOKEN, vault.address, TREASURY, NEW_TOKEN_PRICE);
		await icoGov.deployed();
		console.log('ICOGov deployed to:', icoGov.address);

		//transfer owner to ICOGov
		await govToken.transferOwnership(icoGov.address);

		//mint base token (USDT) to admin, attacker
		await setTokenBalance(BASE_TOKEN, platformAdmin.address, utils.parseEther('2000000'));
		await setTokenBalance(BASE_TOKEN, attacker.address, utils.parseEther('2000000'));
		baseTokenContract = govToken.attach(BASE_TOKEN);
		expect(await baseTokenContract.balanceOf(platformAdmin.address)).to.equal(utils.parseEther('2000000'));
		expect(await baseTokenContract.balanceOf(attacker.address)).to.equal(utils.parseEther('2000000'));

		//deposit to Vault
		baseTokenContract.approve(vault.address, utils.parseEther('1000000'));
		await vault.deposit(utils.parseEther('1000000'));
		expect(await vault.balanceOf(platformAdmin.address)).to.equal(utils.parseEther('1000000'));
	});

	it('Attack', async function () {
		baseTokenContract = govToken.attach(BASE_TOKEN).connect(attacker);
		vault = vault.connect(attacker);
		govToken = govToken.connect(attacker);
		icoGov = icoGov.connect(attacker);

		// EvilToken
		const EvilToken = await hre.ethers.getContractFactory('EvilERC20', attacker);
		const evilToken = await EvilToken.deploy(vault.address, icoGov.address, govToken.address);
		await evilToken.deployed();
		expect(await evilToken.balanceOf(attacker.address)).to.equal(utils.parseEther('3000000'));
		console.log('EvilToken deployed to:', evilToken.address);

		console.log('[BEFORE ATTACK]');
		console.log('[ATTACKER] BASE TOKEN', utils.formatEther(await baseTokenContract.balanceOf(attacker.address)));
		console.log('[ATTACKER] GOV TOKEN', utils.formatEther(await govToken.balanceOf(attacker.address)));
		console.log('[ATTACKER] EVIL TOKEN', utils.formatEther(await evilToken.balanceOf(attacker.address)));
		console.log('[VAULT] BASE TOKEN', utils.formatEther(await baseTokenContract.balanceOf(vault.address)));

		// write your exploit here.

		console.log('[AFTER ATTACK]');
		console.log('[ATTACKER] BASE TOKEN', utils.formatEther(await baseTokenContract.balanceOf(attacker.address)));
		console.log('[ATTACKER] GOV TOKEN', utils.formatEther(await govToken.balanceOf(attacker.address)));
		console.log('[ATTACKER] EVIL TOKEN', utils.formatEther(await evilToken.balanceOf(attacker.address)));
		console.log('[VAULT] BASE TOKEN', utils.formatEther(await baseTokenContract.balanceOf(vault.address)));
	});
});
